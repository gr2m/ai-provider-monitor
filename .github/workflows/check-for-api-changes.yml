name: Check for API Changes

on:
  # Run every hour
  schedule:
    - cron: "0 * * * *"
  # Allow manual triggering
  workflow_dispatch:
  # Run when the workflow file is changed
  push:
    branches: [main]
    paths:
      - ".github/workflows/check-for-api-changes.yml"

jobs:
  check:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    strategy:
      fail-fast: false
      matrix:
        source:
          - name: anthropic
            openapi_url: "https://storage.googleapis.com/stainless-sdk-openapi-specs/anthropic%2Fanthropic-29a6b7ba51942cd606e5bf4b533e5aac1bef42f6d4b1f7f45f756304cf676782.yml"
            filename: "openapi.json"
          - name: assemblyai
            openapi_url: "https://raw.githubusercontent.com/AssemblyAI/assemblyai-api-spec/refs/heads/main/openapi.yml"
            filename: "openapi.yml"
          - name: cohere
            openapi_url: "https://raw.githubusercontent.com/cohere-ai/cohere-developer-experience/main/cohere-openapi.yaml"
            filename: openapi.yml
          - name: groq
            openapi_url: "https://api.groq.com/openapi"
            filename: openapi.json
          - name: mistral
            openapi_url: "https://raw.githubusercontent.com/mistralai/platform-docs-public/main/openapi.yaml"
            filename: openapi.yml
          - name: openai
            openapi_url: "https://app.stainless.com/api/spec/documented/openai/openapi.documented.yml"
            filename: openapi.yml
          - name: togetherai
            openapi_url: "https://raw.githubusercontent.com/togethercomputer/openapi/refs/heads/main/openapi.yaml"
            filename: openapi.yml
          - name: xai
            openapi_url: "https://api.x.ai/api-docs/openapi.json"
            filename: openapi.json

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Create cache directory
        run: mkdir -p cache/${{ matrix.source.name }}

      - name: Download API specification
        id: detect-first-run
        run: |
          # Check if this is the first run (no previous spec exists)
          if [ ! -f "cache/${{ matrix.source.name }}/${{ matrix.source.filename }}" ]; then
            echo "first_run=true" >> $GITHUB_OUTPUT
            echo "New specification detected"
            exit 0
          fi

      - name: Download
        id: download
        run: |
          # Download the current OpenAPI API spec
          # Set the output file path using matrix.source.filename
          output_file="cache/${{ matrix.source.name }}/${{ matrix.source.filename }}"
          # Download to cache
          curl -s "${{ matrix.source.openapi_url }}" -o "$output_file"
          # Set the file path as an output variable
          echo "file_path=$output_file" >> $GITHUB_OUTPUT

      - name: Sort keys in OpenAPI specification
        id: fetch-url
        run: |
          # install yq
          wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x /usr/local/bin/yq

          # sort keys in the file
          yq -i -P 'sort_keys(..)' ${{ steps.download.outputs.file_path }}

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: package.json
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Format specification
        run: |
          # Format the file
          npx prettier --write "${{ steps.download.outputs.file_path }}"

      - name: generate route files
        run: |
          # delete existing route files
          rm -rf cache/${{ matrix.source.name }}/routes

          # Generate route files
          node scripts/dereference-and-split-into-route-files.js ${{ matrix.source.name }}

      # If this is the first run, create PR with the initial spec
      - name: Create initial PR
        if: steps.detect-first-run.outputs.first_run == 'true'
        uses: peter-evans/create-pull-request@v8
        with:
          title: "feat: add initial ${{ matrix.source.name }} API specification"
          body: |
            The initial ${{ matrix.source.name }} API specification file for monitoring changes.

            This repository will now track changes to the ${{ matrix.source.name }} API specification and create automated pull requests when changes are detected.
          branch: update/${{ matrix.source.name }}
          delete-branch: true
          labels: |
            provider:${{ matrix.source.name }}
          commit-message: "feat: add initial ${{ matrix.source.name }} API specification"

      - name: Stage changes
        if: steps.detect-first-run.outputs.first_run != 'true'
        run: |
          # Stage all changes including new files
          git add cache/${{ matrix.source.name }}/

      - name: Detect changes
        if: steps.detect-first-run.outputs.first_run != 'true'
        id: detect-changes
        run: |
          # Compare with previous version using git (including staged changes)
          if ! git diff --quiet --cached HEAD cache/${{ matrix.source.name }}/routes/**; then
            echo "changes_detected=true" >> $GITHUB_OUTPUT
            echo "Changes detected in ${{ matrix.source.name }} API specification"
          else
            echo "changes_detected=false" >> $GITHUB_OUTPUT
            echo "No changes detected"
          fi

      - name: Diff
        if: steps.detect-changes.outputs.changes_detected == 'true'
        id: diff
        run: |
          # Get file changes summary
          FILE_CHANGES=$(git diff --cached --name-status HEAD cache/${{ matrix.source.name }}/routes/**)
          
          # Get detailed diff only for modified files (M)
          MODIFIED_FILES=$(echo "$FILE_CHANGES" | grep "^M" | cut -f2)
          
          if [ -n "$MODIFIED_FILES" ]; then
            MODIFIED_DIFF=$(git diff --cached HEAD $MODIFIED_FILES)
          else
            MODIFIED_DIFF=""
          fi
          
          # Combine for LLM
          echo "text<<EOF" >> $GITHUB_OUTPUT
          echo "File changes:" >> $GITHUB_OUTPUT
          echo "$FILE_CHANGES" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          if [ -n "$MODIFIED_DIFF" ]; then
            echo "Modified files details:" >> $GITHUB_OUTPUT
            echo "$MODIFIED_DIFF" >> $GITHUB_OUTPUT
          fi
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Get today's date
        if: steps.detect-changes.outputs.changes_detected == 'true'
        id: today
        run: echo "date=$(date -u +%Y-%m-%d)" >> $GITHUB_OUTPUT

      - name: Debug diff
        if: steps.detect-changes.outputs.changes_detected == 'true'
        run: |
          echo "FILE_CHANGES:"
          git diff --cached --name-status HEAD cache/${{ matrix.source.name }}/routes/**
          echo ""
          
          MODIFIED_FILES=$(git diff --cached --name-status HEAD cache/${{ matrix.source.name }}/routes/** | grep "^M" | cut -f2)
          if [ -n "$MODIFIED_FILES" ]; then
            echo "MODIFIED_DIFF:"
            git diff --cached HEAD $MODIFIED_FILES
            echo ""
          fi

      - name: Analyze changes
        if: steps.detect-changes.outputs.changes_detected == 'true'
        id: analyze
        uses: vercel/ai-action@v2
        with:
          model: "openai/gpt-5.2-pro"
          api-key: ${{ secrets.AI_GATEWAY_API_KEY }}
          prompt: |
            Analyze the following OpenAPI specification diff and produce structured change records.

            Derive the route from the file path in the diff. For example, changes in `cache/cohere/routes/v2/chat/post.json` belong to the `POST /v2/chat` route.

            For each logical change, create a record with:
            - route: "METHOD /path" (e.g. "POST /v1/chat/completions")
            - change: "added", "changed", or "removed"
            - target: "route" (endpoint added/removed), "request", or "response"
            - breaking: true/false
            - deprecated: true if the change marks something as deprecated
            - doc_only: true if only descriptions/examples changed, not schema structure
            - note: human-readable summary of the change
            - paths: array of {path, before, after} objects describing specific property changes. Use JSON-path-like notation relative to the route spec (e.g. "requestBody.schema.properties.model.type"). Set before to null for additions, after to null for removals.

            Also provide:
            - summary: conventional commit message summarizing all changes (max 100 chars)
            - description: markdown description with sections for breaking changes, new features, and fixes, grouped by route

            Today's date is ${{ steps.today.outputs.date }}.

            Diff:
            ${{ steps.diff.outputs.text }}
          schema: |
            {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "title": "Structured Change Analysis",
              "type": "object",
              "properties": {
                "summary": {
                  "type": "string",
                  "description": "Conventional commit message summarizing all changes (max 100 chars)."
                },
                "description": {
                  "type": "string",
                  "description": "Markdown description of changes."
                },
                "changes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "route": { "type": "string", "description": "METHOD /path" },
                      "date": { "type": "string", "description": "ISO date (YYYY-MM-DD)" },
                      "change": { "type": "string", "enum": ["added", "changed", "removed"] },
                      "target": { "type": "string", "enum": ["route", "request", "response"] },
                      "breaking": { "type": "boolean" },
                      "deprecated": { "type": "boolean" },
                      "doc_only": { "type": "boolean" },
                      "note": { "type": "string" },
                      "paths": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "path": { "type": "string" },
                            "before": {},
                            "after": {}
                          },
                          "required": ["path", "before", "after"]
                        }
                      }
                    },
                    "required": ["route", "date", "change", "target", "breaking", "deprecated", "doc_only", "note", "paths"]
                  }
                }
              },
              "required": ["summary", "description", "changes"],
              "additionalProperties": false
            }

      - name: Append change records
        if: steps.detect-changes.outputs.changes_detected == 'true'
        run: |
          node scripts/append-changes.js "${{ matrix.source.name }}" '${{ toJson(fromJson(steps.analyze.outputs.json).changes) }}'
          git add changes/

      - name: Create Pull Request
        id: create-pr
        if: steps.detect-changes.outputs.changes_detected == 'true'
        uses: peter-evans/create-pull-request@v8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Update ${{ matrix.source.name }} API specification"
          title: ${{ fromJson(steps.analyze.outputs.json).summary }}
          body: ${{ fromJson(steps.analyze.outputs.json).description }}
          branch: update/${{ matrix.source.name }}
          delete-branch: true
          labels: |
            provider:${{ matrix.source.name }}
          assignees: ${{ github.repository_owner }}

      # use gh CLI to merge the PR with squash and merge
      - uses: actions/create-github-app-token@v2
        if: steps.create-pr.outputs.pull-request-url != ''
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
      - name: Merge the pull request
        if: steps.create-pr.outputs.pull-request-url != ''
        run: |
          gh pr merge ${{ steps.create-pr.outputs.pull-request-number }} --squash --delete-branch --repo ${{ github.repository }}
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Summary
        run: |
          if [ "${{ steps.detect-first-run.outputs.first_run }}" = "true" ]; then
            echo "âœ… First run completed - ${{ matrix.source.name }} API specification saved"
          elif [ "${{ steps.detect-changes.outputs.changes_detected }}" = "true" ]; then
            echo "ðŸ”„ Changes detected - Pull request created: ${{ steps.create-pr.outputs.pull-request-url }}"
          else
            echo "âœ… No changes detected - ${{ matrix.source.name }} API specification is up to date"
          fi
