name: Check for API Changes

on:
  # Run every hour
  schedule:
    - cron: "0 * * * *"
  # Allow manual triggering
  workflow_dispatch:
  # Run when the workflow file is changed
  push:
    branches: [main]
    paths:
      - ".github/workflows/check-for-api-changes.yml"

jobs:
  # Job 1: Per-provider detection of changed routes
  detect:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    strategy:
      fail-fast: false
      matrix:
        source:
          - name: anthropic
            openapi_url: "https://storage.googleapis.com/stainless-sdk-openapi-specs/anthropic%2Fanthropic-29a6b7ba51942cd606e5bf4b533e5aac1bef42f6d4b1f7f45f756304cf676782.yml"
            filename: "openapi.json"
          - name: assemblyai
            openapi_url: "https://raw.githubusercontent.com/AssemblyAI/assemblyai-api-spec/refs/heads/main/openapi.yml"
            filename: "openapi.yml"
          - name: cohere
            openapi_url: "https://raw.githubusercontent.com/cohere-ai/cohere-developer-experience/main/cohere-openapi.yaml"
            filename: openapi.yml
          - name: groq
            openapi_url: "https://api.groq.com/openapi"
            filename: openapi.json
          - name: mistral
            openapi_url: "https://raw.githubusercontent.com/mistralai/platform-docs-public/main/openapi.yaml"
            filename: openapi.yml
          - name: openai
            openapi_url: "https://app.stainless.com/api/spec/documented/openai/openapi.documented.yml"
            filename: openapi.yml
          - name: togetherai
            openapi_url: "https://raw.githubusercontent.com/togethercomputer/openapi/refs/heads/main/openapi.yaml"
            filename: openapi.yml
          - name: xai
            openapi_url: "https://api.x.ai/api-docs/openapi.json"
            filename: openapi.json

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Create cache directory
        run: mkdir -p cache/${{ matrix.source.name }}

      - name: Download API specification
        id: detect-first-run
        run: |
          # Check if this is the first run (no previous spec exists)
          if [ ! -f "cache/${{ matrix.source.name }}/${{ matrix.source.filename }}" ]; then
            echo "first_run=true" >> $GITHUB_OUTPUT
            echo "New specification detected"
            exit 0
          fi

      - name: Download
        id: download
        run: |
          output_file="cache/${{ matrix.source.name }}/${{ matrix.source.filename }}"
          curl -s "${{ matrix.source.openapi_url }}" -o "$output_file"
          echo "file_path=$output_file" >> $GITHUB_OUTPUT

      - name: Sort keys in OpenAPI specification
        run: |
          wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x /usr/local/bin/yq
          yq -i -P 'sort_keys(..)' ${{ steps.download.outputs.file_path }}

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: package.json
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Format specification
        run: npx prettier --write "${{ steps.download.outputs.file_path }}"

      - name: Generate route files
        run: |
          rm -rf cache/${{ matrix.source.name }}/routes
          node scripts/dereference-and-split-into-route-files.js ${{ matrix.source.name }}

      # If this is the first run, create PR with the initial spec
      - name: Create initial PR
        if: steps.detect-first-run.outputs.first_run == 'true'
        uses: peter-evans/create-pull-request@v8
        with:
          title: "feat: add initial ${{ matrix.source.name }} API specification"
          body: |
            The initial ${{ matrix.source.name }} API specification file for monitoring changes.

            This repository will now track changes to the ${{ matrix.source.name }} API specification and create automated pull requests when changes are detected.
          branch: update/${{ matrix.source.name }}
          delete-branch: true
          labels: |
            provider:${{ matrix.source.name }}
          commit-message: "feat: add initial ${{ matrix.source.name }} API specification"

      - name: Stage changes
        if: steps.detect-first-run.outputs.first_run != 'true'
        run: git add cache/${{ matrix.source.name }}/

      - name: Detect changes
        if: steps.detect-first-run.outputs.first_run != 'true'
        id: detect-changes
        run: |
          if ! git diff --quiet --cached HEAD cache/${{ matrix.source.name }}/routes/**; then
            echo "changes_detected=true" >> $GITHUB_OUTPUT
          else
            echo "changes_detected=false" >> $GITHUB_OUTPUT
          fi

      - name: Build changed routes list
        if: steps.detect-changes.outputs.changes_detected == 'true'
        run: |
          PROVIDER="${{ matrix.source.name }}"
          mkdir -p route-changes

          # List changed route files with status (A=added, M=modified, D=deleted)
          git diff --cached --name-status HEAD "cache/${PROVIDER}/routes/**" | while IFS=$'\t' read -r status file; do
            # Derive route: cache/openai/routes/chat/completions/post.json â†’ POST /chat/completions
            ROUTE_PATH=$(echo "$file" | sed "s|cache/${PROVIDER}/routes/||" | sed 's|/[^/]*\.json$||')
            METHOD=$(basename "$file" .json | tr '[:lower:]' '[:upper:]')
            ROUTE="${METHOD} /${ROUTE_PATH}"

            # Sanitize file path for artifact name
            SAFE_NAME=$(echo "$file" | sed "s|cache/${PROVIDER}/routes/||" | sed 's|/|--|g' | sed 's|\.json$||')

            echo "{\"provider\":\"${PROVIDER}\",\"file\":\"${file}\",\"status\":\"${status}\",\"route\":\"${ROUTE}\",\"safe_name\":\"${SAFE_NAME}\"}" > "route-changes/${SAFE_NAME}.json"
          done

          echo "Changed routes:"
          cat route-changes/*.json 2>/dev/null || echo "none"

      - name: Upload new cache
        if: steps.detect-changes.outputs.changes_detected == 'true'
        uses: actions/upload-artifact@v6
        with:
          name: cache-${{ matrix.source.name }}
          path: cache/${{ matrix.source.name }}/

      - name: Upload changed routes list
        if: steps.detect-changes.outputs.changes_detected == 'true'
        uses: actions/upload-artifact@v6
        with:
          name: changed-routes-${{ matrix.source.name }}
          path: route-changes/

      - name: Summary
        run: |
          if [ "${{ steps.detect-first-run.outputs.first_run }}" = "true" ]; then
            echo "âœ… First run completed - ${{ matrix.source.name }} API specification saved"
          elif [ "${{ steps.detect-changes.outputs.changes_detected }}" = "true" ]; then
            echo "ðŸ”„ Changes detected in ${{ matrix.source.name }}"
          else
            echo "âœ… No changes detected - ${{ matrix.source.name }} is up to date"
          fi

  # Job 2: Collect all changed routes into a single matrix
  build-matrix:
    needs: detect
    runs-on: ubuntu-latest
    outputs:
      route_matrix: ${{ steps.matrix.outputs.routes }}
      provider_matrix: ${{ steps.matrix.outputs.providers }}
      has_changes: ${{ steps.matrix.outputs.has_changes }}
    steps:
      - name: Download changed routes artifacts
        uses: actions/download-artifact@v7
        with:
          pattern: changed-routes-*
          path: all-changes/

      - name: Build matrix
        id: matrix
        run: |
          ROUTES="[]"
          PROVIDERS="[]"

          # Process each provider's changed routes
          for dir in all-changes/changed-routes-*/; do
            [ -d "$dir" ] || continue
            for f in "$dir"*.json; do
              [ -f "$f" ] || continue
              ENTRY=$(cat "$f")
              ROUTES=$(echo "$ROUTES" | jq --argjson entry "$ENTRY" '. + [$entry]')
              PROVIDER=$(echo "$ENTRY" | jq -r '.provider')
              PROVIDERS=$(echo "$PROVIDERS" | jq --arg p "$PROVIDER" 'if index($p) then . else . + [$p] end')
            done
          done

          ROUTE_COUNT=$(echo "$ROUTES" | jq length)
          echo "Found $ROUTE_COUNT changed routes across $(echo "$PROVIDERS" | jq length) providers"
          echo "$ROUTES" | jq .

          echo "routes=$(echo "$ROUTES" | jq -c .)" >> $GITHUB_OUTPUT
          echo "providers=$(echo "$PROVIDERS" | jq -c .)" >> $GITHUB_OUTPUT

          if [ "$ROUTE_COUNT" -gt 0 ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

  # Job 3: Analyze each changed route individually
  analyze:
    needs: build-matrix
    if: needs.build-matrix.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        route: ${{ fromJson(needs.build-matrix.outputs.route_matrix) }}
    steps:
      - name: Checkout repository (old state)
        uses: actions/checkout@v6

      - name: Download new cache
        uses: actions/download-artifact@v7
        with:
          name: cache-${{ matrix.route.provider }}
          path: new-cache/

      - name: Get today's date
        id: today
        run: echo "date=$(date -u +%Y-%m-%d)" >> $GITHUB_OUTPUT

      - name: Prepare old and new spec files
        id: specs
        run: |
          PROVIDER="${{ matrix.route.provider }}"
          FILE="${{ matrix.route.file }}"
          STATUS="${{ matrix.route.status }}"
          RELATIVE="${FILE#cache/${PROVIDER}/}"

          OLD_FILE="$FILE"
          NEW_FILE="new-cache/${RELATIVE}"

          # Check which files actually exist
          [ "$STATUS" != "A" ] && [ -f "$OLD_FILE" ] && echo "old_file=$OLD_FILE" >> $GITHUB_OUTPUT
          [ "$STATUS" != "D" ] && [ -f "$NEW_FILE" ] && echo "new_file=$NEW_FILE" >> $GITHUB_OUTPUT

          echo "status=$STATUS" >> $GITHUB_OUTPUT

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: package.json
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Analyze route change
        id: analyze
        env:
          OPENAI_API_KEY: ${{ secrets.AI_GATEWAY_API_KEY }}
        run: |
          ARGS=("${{ matrix.route.status }}" "${{ matrix.route.route }}" "${{ steps.today.outputs.date }}")
          [ -n "${{ steps.specs.outputs.old_file }}" ] && ARGS+=("${{ steps.specs.outputs.old_file }}") || ARGS+=("")
          [ -n "${{ steps.specs.outputs.new_file }}" ] && ARGS+=("${{ steps.specs.outputs.new_file }}") || ARGS+=("")

          RESULT=$(node scripts/analyze-route-change.js "${ARGS[@]}")
          echo "Analysis result:"
          echo "$RESULT" | jq .

          # Save to file for artifact upload
          echo "$RESULT" > analysis-result.json

      - name: Upload analysis result
        uses: actions/upload-artifact@v6
        with:
          name: analysis-${{ matrix.route.provider }}--${{ matrix.route.safe_name }}
          path: analysis-result.json

  # Job 4: Collect results and create PR per provider
  update:
    needs: [build-matrix, analyze]
    if: needs.build-matrix.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    strategy:
      fail-fast: false
      matrix:
        provider: ${{ fromJson(needs.build-matrix.outputs.provider_matrix) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: package.json
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Download new cache
        uses: actions/download-artifact@v7
        with:
          name: cache-${{ matrix.provider }}
          path: new-cache/

      - name: Copy updated cache to working tree
        run: |
          rm -rf cache/${{ matrix.provider }}/
          cp -r new-cache/ cache/${{ matrix.provider }}/

      - name: Download analysis results
        uses: actions/download-artifact@v7
        with:
          pattern: analysis-${{ matrix.provider }}--*
          path: analysis-results/

      - name: Collect change records and create PR description
        id: collect
        run: |
          ALL_CHANGES="[]"
          ALL_SUMMARIES=""

          # Merge all analysis results for this provider
          for dir in analysis-results/analysis-${{ matrix.provider }}--*/; do
            [ -d "$dir" ] || continue
            RESULT=$(cat "${dir}analysis-result.json")
            CHANGES=$(echo "$RESULT" | jq '.changes')
            SUMMARY=$(echo "$RESULT" | jq -r '.summary')

            ALL_CHANGES=$(echo "$ALL_CHANGES" | jq --argjson c "$CHANGES" '. + $c')
            ALL_SUMMARIES="${ALL_SUMMARIES}- ${SUMMARY}\n"
          done

          CHANGE_COUNT=$(echo "$ALL_CHANGES" | jq length)
          echo "Collected $CHANGE_COUNT change records"

          # Build PR title
          if [ "$CHANGE_COUNT" -eq 1 ]; then
            TITLE=$(echo "$ALL_CHANGES" | jq -r '.[0].note' | head -c 100)
          else
            TITLE="update ${{ matrix.provider }} API specification (${CHANGE_COUNT} changes)"
          fi

          # Build PR body from change records
          BODY=""
          BREAKING=$(echo "$ALL_CHANGES" | jq '[.[] | select(.breaking == true)]')
          FEATURES=$(echo "$ALL_CHANGES" | jq '[.[] | select(.breaking == false and .change != "removed" and .doc_only == false)]')
          FIXES=$(echo "$ALL_CHANGES" | jq '[.[] | select(.doc_only == true)]')

          if [ "$(echo "$BREAKING" | jq length)" -gt 0 ]; then
            BODY="${BODY}### Breaking changes\n\n"
            for row in $(echo "$BREAKING" | jq -r '.[] | @base64'); do
              ROUTE=$(echo "$row" | base64 -d | jq -r '.route')
              NOTE=$(echo "$row" | base64 -d | jq -r '.note')
              BODY="${BODY}- **${ROUTE}**: ${NOTE}\n"
            done
            BODY="${BODY}\n"
          fi

          if [ "$(echo "$FEATURES" | jq length)" -gt 0 ]; then
            BODY="${BODY}### New features\n\n"
            for row in $(echo "$FEATURES" | jq -r '.[] | @base64'); do
              ROUTE=$(echo "$row" | base64 -d | jq -r '.route')
              NOTE=$(echo "$row" | base64 -d | jq -r '.note')
              BODY="${BODY}- **${ROUTE}**: ${NOTE}\n"
            done
            BODY="${BODY}\n"
          fi

          if [ "$(echo "$FIXES" | jq length)" -gt 0 ]; then
            BODY="${BODY}### Documentation fixes\n\n"
            for row in $(echo "$FIXES" | jq -r '.[] | @base64'); do
              ROUTE=$(echo "$row" | base64 -d | jq -r '.route')
              NOTE=$(echo "$row" | base64 -d | jq -r '.note')
              BODY="${BODY}- **${ROUTE}**: ${NOTE}\n"
            done
          fi

          # Save outputs
          echo "title=${TITLE}" >> $GITHUB_OUTPUT

          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo -e "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "changes=$(echo "$ALL_CHANGES" | jq -c .)" >> $GITHUB_OUTPUT

      - name: Append change records
        run: |
          node scripts/append-changes.js "${{ matrix.provider }}" '${{ steps.collect.outputs.changes }}'

      - name: Create Pull Request
        id: create-pr
        uses: peter-evans/create-pull-request@v8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Update ${{ matrix.provider }} API specification"
          title: ${{ steps.collect.outputs.title }}
          body: ${{ steps.collect.outputs.body }}
          branch: update/${{ matrix.provider }}
          delete-branch: true
          labels: |
            provider:${{ matrix.provider }}
          assignees: ${{ github.repository_owner }}

      # Auto-merge the PR
      - uses: actions/create-github-app-token@v2
        if: steps.create-pr.outputs.pull-request-url != ''
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
      - name: Merge the pull request
        if: steps.create-pr.outputs.pull-request-url != ''
        run: |
          gh pr merge ${{ steps.create-pr.outputs.pull-request-number }} --squash --delete-branch --repo ${{ github.repository }}
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Summary
        run: echo "ðŸ”„ PR created for ${{ matrix.provider }} - ${{ steps.create-pr.outputs.pull-request-url }}"
