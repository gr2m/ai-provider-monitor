name: Check for API Changes

on:
  # Run every hour
  schedule:
    - cron: "0 * * * *"
  # Allow manual triggering
  workflow_dispatch:
  # Run when the workflow file is changed
  push:
    branches: [main]
    paths:
      - ".github/workflows/check-for-api-changes.yml"

jobs:
  check:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    strategy:
      fail-fast: false
      matrix:
        source:
          - name: anthropic
            openapi_url: "https://storage.googleapis.com/stainless-sdk-openapi-specs/anthropic%2Fanthropic-9c7d1ea59095c76b24f14fe279825c2b0dc10f165a973a46b8a548af9aeda62e.yml"
            filename: "openapi.json"
          - name: assemblyai
            openapi_url: "https://raw.githubusercontent.com/AssemblyAI/assemblyai-api-spec/refs/heads/main/openapi.yml"
            filename: "openapi.yml"
          - name: cohere
            openapi_url: "https://raw.githubusercontent.com/cohere-ai/cohere-developer-experience/main/cohere-openapi.yaml"
            filename: openapi.yml
          - name: groq
            openapi_url: "https://api.groq.com/openapi"
            filename: openapi.json
          - name: mistral
            openapi_url: "https://docs.mistral.ai/redocusaurus/plugin-redoc-0.yaml"
            filename: openapi.yml
          - name: openai
            openapi_url: "https://app.stainless.com/api/spec/documented/openai/openapi.documented.yml"
            filename: openapi.yml
          - name: togetherai
            openapi_url: "https://raw.githubusercontent.com/togethercomputer/openapi/refs/heads/main/openapi.yaml"
            filename: openapi.yml
          - name: xai
            openapi_url: "https://api.x.ai/api-docs/openapi.json"
            filename: openapi.json

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Create cache directory
        run: mkdir -p cache/${{ matrix.source.name }}

      - name: Download API specification
        id: detect-first-run
        run: |
          # Check if this is the first run (no previous spec exists)
          if [ ! -f "cache/${{ matrix.source.name }}/${{ matrix.source.filename }}" ]; then
            echo "first_run=true" >> $GITHUB_OUTPUT
            echo "New specification detected"
            exit 0
          fi

      - name: Download
        id: download
        run: |
          # Download the current OpenAPI API spec
          # Set the output file path using matrix.source.filename
          output_file="cache/${{ matrix.source.name }}/${{ matrix.source.filename }}"
          # Download to cache
          curl -s "${{ matrix.source.openapi_url }}" -o "$output_file"
          # Set the file path as an output variable
          echo "file_path=$output_file" >> $GITHUB_OUTPUT

      - name: Sort keys in OpenAPI specification
        id: fetch-url
        run: |
          # install yq
          wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod +x /usr/local/bin/yq

          # sort keys in the file
          yq -i -P 'sort_keys(..)' ${{ steps.download.outputs.file_path }}

      - name: Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version-file: package.json
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Format specification
        run: |
          # Format the file
          npx prettier --write "${{ steps.download.outputs.file_path }}"

      - name: generate route files
        run: node scripts/dereference-and-split-into-route-files.js

      # If this is the first run, create PR with the initial spec
      - name: Create initial PR
        if: steps.detect-first-run.outputs.first_run == 'true'
        uses: peter-evans/create-pull-request@v7
        with:
          title: "feat: add initial ${{ matrix.source.name }} API specification"
          body: |
            The initial ${{ matrix.source.name }} API specification file for monitoring changes.

            This repository will now track changes to the ${{ matrix.source.name }} API specification and create automated pull requests when changes are detected.
          branch: update/${{ matrix.source.name }}
          delete-branch: true
          labels: |
            provider:${{ matrix.source.name }}
            version:breaking
          commit-message: "feat: add initial ${{ matrix.source.name }} API specification"

      - name: Detect changes
        if: steps.detect-first-run.outputs.first_run != 'true'
        id: detect-changes
        run: |
          # Compare with previous version using git
          if ! git diff --quiet HEAD cache/${{ matrix.source.name }}/${{ matrix.source.filename }}; then
            echo "changes_detected=true" >> $GITHUB_OUTPUT
            echo "Changes detected in ${{ matrix.source.name }} API specification"
          else
            echo "changes_detected=false" >> $GITHUB_OUTPUT
            echo "No changes detected"
          fi

      - name: Diff
        if: steps.detect-changes.outputs.changes_detected == 'true'
        id: diff
        run: |
          GIT_DIFF=$(git diff) 
          echo "text<<EOF" >> $GITHUB_OUTPUT
          echo "$GIT_DIFF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate release notes
        if: steps.detect-changes.outputs.changes_detected == 'true'
        id: release-notes
        uses: vercel/ai-action@v2
        with:
          model: "openai/gpt5"
          api-key: ${{ secrets.AI_GATEWAY_API_KEY }}
          prompt: |
            Analyze the following OpenAPI specification diff and calculate these three things

            1. Summary of changes as conventional commit messages (max. 100 characters)
            2. A detailed description of the changes, in markdown format
            3. The type of version change: "breaking", "feature", or "fix"

            For the markdown description, create three sections, each with its own level 3 header:

            1. Breaking changes (removed endpoints, parameters, or changed behavior)
            2. New features (new endpoints, parameters, or options)
            3. Fixes (documentation updates, typo corrections)

            If a section has no content, omit it from the release notes.

            Do not list items in new features that are listed in breaking changes.
            Do not list items in fixes that are listed in breaking changes or new features.

            Diff:
            ${{ steps.diff.outputs.text }}
          schema: |
            {
              "$schema": "http://json-schema.org/draft-07/schema#",
              "title": "Change Description",
              "type": "object",
              "properties": {
                "summary": {
                  "type": "string",
                  "description": "Summary of changes as conventional commit messages (max. 100 characters)."
                },
                "description": {
                  "type": "string",
                  "description": "Description of the change, in markdown format."
                },
                "version": {
                  "type": "string",
                  "enum": ["breaking", "feature", "fix"],
                  "description": "The type of version change."
                }
              },
              "required": ["summary", "description", "version"],
              "additionalProperties": false
            }

      - name: Create Pull Request
        id: create-pr
        if: steps.detect-changes.outputs.changes_detected == 'true'
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Update ${{ matrix.source.name }} API specification"
          title: ${{ fromJson(steps.release-notes.outputs.json).summary }}
          body: ${{ fromJson(steps.release-notes.outputs.json).description }}
          branch: update/${{ matrix.source.name }}
          delete-branch: true
          labels: |
            version:${{ fromJson(steps.release-notes.outputs.json).version }}
            provider:${{ matrix.source.name }}
          assignees: ${{ github.repository_owner }}

      # use gh CLI to merge the PR with squash and merge
      - uses: actions/create-github-app-token@v2
        if: steps.create-pr.outputs.pull-request-url != ''
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
      - name: Merge the pull request
        if: steps.create-pr.outputs.pull-request-url != ''
        run: |
          gh pr merge ${{ steps.create-pr.outputs.pull-request-number }} --squash --delete-branch --repo ${{ github.repository }}
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Summary
        run: |
          if [ "${{ steps.detect-first-run.outputs.first_run }}" = "true" ]; then
            echo "âœ… First run completed - ${{ matrix.source.name }} API specification saved"
          elif [ "${{ steps.detect-changes.outputs.changes_detected }}" = "true" ]; then
            echo "ðŸ”„ Changes detected - Pull request created: ${{ steps.create-pr.outputs.pull-request-url }}"
          else
            echo "âœ… No changes detected - ${{ matrix.source.name }} API specification is up to date"
          fi
