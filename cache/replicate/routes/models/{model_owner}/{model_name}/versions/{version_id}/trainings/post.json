{
  "description": "Start a new training of the model version you specify.\n\nExample request body:\n\n```json\n{\n  \"destination\": \"{new_owner}/{new_name}\",\n  \"input\": {\n    \"train_data\": \"https://example.com/my-input-images.zip\",\n  },\n  \"webhook\": \"https://example.com/my-webhook\",\n}\n```\n\nExample cURL request:\n\n```console\ncurl -s -X POST \\\n  -d '{\"destination\": \"{new_owner}/{new_name}\", \"input\": {\"input_images\": \"https://example.com/my-input-images.zip\"}}' \\\n  -H \"Authorization: Bearer $REPLICATE_API_TOKEN\" \\\n  -H 'Content-Type: application/json' \\\n  https://api.replicate.com/v1/models/stability-ai/sdxl/versions/da77bc59ee60423279fd632efb4795ab731d9e3ca9705ef3341091fb989b7eaf/trainings\n```\n\nThe response will be the training object:\n\n```json\n{\n  \"id\": \"zz4ibbonubfz7carwiefibzgga\",\n  \"model\": \"stability-ai/sdxl\",\n  \"version\": \"da77bc59ee60423279fd632efb4795ab731d9e3ca9705ef3341091fb989b7eaf\",\n  \"input\": {\n    \"input_images\": \"https://example.com/my-input-images.zip\"\n  },\n  \"logs\": \"\",\n  \"error\": null,\n  \"status\": \"starting\",\n  \"created_at\": \"2023-09-08T16:32:56.990893084Z\",\n  \"urls\": {\n    \"web\": \"https://replicate.com/p/zz4ibbonubfz7carwiefibzgga\",\n     \"get\": \"https://api.replicate.com/v1/predictions/zz4ibbonubfz7carwiefibzgga\",\n     \"cancel\": \"https://api.replicate.com/v1/predictions/zz4ibbonubfz7carwiefibzgga/cancel\"\n  }\n}\n```\n\nAs models can take several minutes or more to train, the result will not be available immediately. To get the final result of the training you should either provide a `webhook` HTTPS URL for us to call when the results are ready, or poll the [get a training](#trainings.get) endpoint until it has finished.\n\nWhen a training completes, it creates a new [version](https://replicate.com/docs/how-does-replicate-work#terminology) of the model at the specified destination.\n\nTo find some models to train on, check out the [trainable language models collection](https://replicate.com/collections/trainable-language-models).\n",
  "operationId": "trainings.create",
  "parameters": [
    {
      "description": "The name of the user or organization that owns the model.\n",
      "in": "path",
      "name": "model_owner",
      "required": true,
      "schema": {
        "type": "string"
      }
    },
    {
      "description": "The name of the model.\n",
      "in": "path",
      "name": "model_name",
      "required": true,
      "schema": {
        "type": "string"
      }
    },
    {
      "description": "The ID of the version.\n",
      "in": "path",
      "name": "version_id",
      "required": true,
      "schema": {
        "type": "string"
      }
    }
  ],
  "requestBody": {
    "content": {
      "application/json": {
        "schema": {
          "properties": {
            "destination": {
              "description": "A string representing the desired model to push to in the format `{destination_model_owner}/{destination_model_name}`. This should be an existing model owned by the user or organization making the API request. If the destination is invalid, the server will return an appropriate 4XX response.\n",
              "type": "string"
            },
            "input": {
              "description": "An object containing inputs to the Cog model's `train()` function.\n",
              "type": "object"
            },
            "webhook": {
              "description": "An HTTPS URL for receiving a webhook when the training completes. The webhook will be a POST request where the request body is the same as the response body of the [get training](#trainings.get) operation. If there are network problems, we will retry the webhook a few times, so make sure it can be safely called more than once. Replicate will not follow redirects when sending webhook requests to your service, so be sure to specify a URL that will resolve without redirecting.",
              "type": "string"
            },
            "webhook_events_filter": {
              "description": "By default, we will send requests to your webhook URL whenever there are new outputs or the training has finished. You can change which events trigger webhook requests by specifying `webhook_events_filter` in the training request:\n\n- `start`: immediately on training start\n- `output`: each time a training generates an output (note that trainings can generate multiple outputs)\n- `logs`: each time log output is generated by a training\n- `completed`: when the training reaches a terminal state (succeeded/canceled/failed)\n\nFor example, if you only wanted requests to be sent at the start and end of the training, you would provide:\n\n```json\n{\n  \"destination\": \"my-organization/my-model\",\n  \"input\": {\n    \"text\": \"Alice\"\n  },\n  \"webhook\": \"https://example.com/my-webhook\",\n  \"webhook_events_filter\": [\"start\", \"completed\"]\n}\n```\n\nRequests for event types `output` and `logs` will be sent at most once every 500ms. If you request `start` and `completed` webhooks, then they'll always be sent regardless of throttling.\n",
              "items": {
                "enum": [
                  "start",
                  "output",
                  "logs",
                  "completed"
                ],
                "type": "string"
              },
              "type": "array"
            }
          },
          "required": [
            "destination",
            "input"
          ],
          "type": "object"
        }
      }
    }
  },
  "responses": {
    "201": {
      "content": {
        "application/json": {
          "schema": {
            "properties": {
              "completed_at": {
                "description": "The time when the training completed",
                "format": "date-time",
                "type": "string"
              },
              "created_at": {
                "description": "The time when the training was created",
                "format": "date-time",
                "type": "string"
              },
              "error": {
                "description": "Error message if the training failed",
                "nullable": true,
                "type": "string"
              },
              "id": {
                "description": "The unique ID of the training",
                "type": "string"
              },
              "input": {
                "additionalProperties": true,
                "description": "The input parameters used for the training",
                "type": "object"
              },
              "logs": {
                "description": "The logs from the training process",
                "type": "string"
              },
              "metrics": {
                "description": "Metrics about the training process",
                "properties": {
                  "predict_time": {
                    "description": "The amount of CPU or GPU time, in seconds, that the training used while running",
                    "type": "number"
                  },
                  "total_time": {
                    "description": "The total time, in seconds, that the training took to complete",
                    "type": "number"
                  }
                },
                "type": "object"
              },
              "model": {
                "description": "The name of the model in the format owner/name",
                "type": "string"
              },
              "output": {
                "description": "The output of the training process",
                "properties": {
                  "version": {
                    "description": "The version of the model created by the training",
                    "type": "string"
                  },
                  "weights": {
                    "description": "The weights of the trained model",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "source": {
                "description": "How the training was created",
                "enum": [
                  "web",
                  "api"
                ],
                "type": "string"
              },
              "started_at": {
                "description": "The time when the training started",
                "format": "date-time",
                "type": "string"
              },
              "status": {
                "description": "The current status of the training. `canceled` means the training was canceled (either by the user or because it reached its deadline while running). `aborted` means the training was terminated before it started running (for example, when a deadline is reached before the training starts).\n",
                "enum": [
                  "starting",
                  "processing",
                  "succeeded",
                  "failed",
                  "canceled",
                  "aborted"
                ],
                "type": "string"
              },
              "urls": {
                "description": "URLs for interacting with the training",
                "properties": {
                  "cancel": {
                    "description": "URL to cancel the training",
                    "format": "uri",
                    "type": "string"
                  },
                  "get": {
                    "description": "URL to get the training details",
                    "format": "uri",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "version": {
                "description": "The ID of the model version used for training",
                "type": "string"
              }
            },
            "type": "object"
          }
        }
      },
      "description": "Success"
    }
  },
  "summary": "Create a training"
}
